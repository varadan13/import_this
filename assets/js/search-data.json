{
  
    
        "post0": {
            "title": "Code Snippets to practise context managers and a quirky behaviour of functions",
            "content": "def a_simple_context_func(file_address,message,shld_write=True): file=open(file_address,&quot;wt&quot;) if shld_write==True: file.__enter__() file.write(message) file.__exit__() . Context=a_simple_context_func(&quot;/content/sample_data/README.md&quot;,&quot;a simple message to write&quot;) . OR . file=open(&quot;/content/sample_data/README.md&quot;,&quot;wt&quot;) file.__enter__() file.write(&quot;a second message to write&quot;) file.__exit__() . AND THEN . file.write(&quot;a third message that won&#39;t write cus the file is closed&quot;) . ValueError Traceback (most recent call last) &lt;ipython-input-4-2aaf5c7439bd&gt; in &lt;module&gt;() -&gt; 1 file.write(&#34;a third message that won&#39;t write cus the file is closed&#34;) ValueError: I/O operation on closed file. . USING with . with open(&quot;/content/sample_data/README.md&quot;,&quot;wt&quot;) as file: file.write(&quot;fourth message to write using with&quot;) . file # still exists but the connection is closed . &lt;_io.TextIOWrapper name=&#39;/content/sample_data/README.md&#39; mode=&#39;wt&#39; encoding=&#39;UTF-8&#39;&gt; . file.write(&quot;xyx&quot;) . ValueError Traceback (most recent call last) &lt;ipython-input-7-10bc188c1ce1&gt; in &lt;module&gt;() -&gt; 1 file.write(&#34;xyx&#34;) ValueError: I/O operation on closed file. . In Python, the attributes attached to a function will differ based on the return value of that function. . For example, simplet function just returns the parameter. So if the parameter is a string type then the return value of function will have attributes of string type and likewise for float type, interger type parameters. . def simplet(x): return x . A=simplet(1) B=simplet(&quot;string&quot;) C=simplet(1000.2324) . dir(A)==dir(B) . False . dir(A)==dir(C) . False . A_func=simplet B_func=simplet . dir(A_func)==dir(B_func) . True . set(dir(C))-set(dir(A)) . {&#39;__getformat__&#39;, &#39;__set_format__&#39;, &#39;as_integer_ratio&#39;, &#39;fromhex&#39;, &#39;hex&#39;, &#39;is_integer&#39;} .",
            "url": "https://varadan13.github.io/import_this/python_notes/2021/04/09/codesnippet-contextmanag.html",
            "relUrl": "/python_notes/2021/04/09/codesnippet-contextmanag.html",
            "date": " • Apr 9, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Instance and class variable notes.",
            "content": "Instance Variable . Instance variables are owned by instances of the class. | This means that for each object or instance of a class, the instance variables are different. | Unlike class variables, instance variables are defined within methods. . class Potterhead(object): def __init__(self,movie): self.movie = movie #instance variable . | . Class Variable . Class variables are defined within the class construction. | Because they are owned by the class itself, class variables are shared by all instances of the class. . class PotterHead(object): hero=&quot;Dumbeldore&quot; # class variable . | . Different ways to access Instance Variable in Python . There are two ways to access the instance variable of class: . Within the class by using self and object reference. | Using getattr() method | .",
            "url": "https://varadan13.github.io/import_this/python_notes/2021/04/08/instance-classvar.html",
            "relUrl": "/python_notes/2021/04/08/instance-classvar.html",
            "date": " • Apr 8, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "Python executes class body at definition time",
            "content": "class foo: print(&quot;hello batman&quot;) . hello batman . def foo_func(): print(&quot;hello batman&quot;) . foo_func() . hello batman . While executing class body, python evaluates various expressions** inside the class body and stores it in the local name space. | This is done because that namespace then forms the class attributes. | Class bodies are not the only such namespaces; set and dict comprehensions, and in Python 3, list comprehensions are also executed with a separate namespace, scoping their locals. | . ** These expressions could be anything that we write inside the class body such as class variable, instance variable, methods etc . Why does python behave differently for functions? . Basically it fetches the instructions in the definition and stores it to the global variable(if the function is defined in the global scope) taking the value equal to its name. .",
            "url": "https://varadan13.github.io/import_this/python_notes/2021/04/06/pythonnotes1.html",
            "relUrl": "/python_notes/2021/04/06/pythonnotes1.html",
            "date": " • Apr 6, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "Introduction to Iterators and Iterables in Python",
            "content": "In Python programming from the very existence of the words &#39;iterator&#39; and &#39;iterable&#39; we must confirm that these words embody two distinct concepts and we must be clear about their differences. . As a first approximation, we can say that any object that works in a &quot;for loop&quot; is an iterable and within the &quot;for loop&quot; that object is converted to an iterator by the Python interpretor. . Let&#39;s get a little deeper. . To refine the above definition let us discuss how Python creates an iterator out of an object x.(what is happening in a for loop) . To create an iterator Python first calls iter built in function on x and this function checks the following: . whether the object implements $__iter__$ and calls that to obtain an iterator | if not, checks, if the object implements $__getitem__$ and calls that to obtain an iterator | if not Python raises TypeError, usually saying &quot;&#39;C&#39; object is not iterable&quot;, where C is the class of the target object. | import reprlib import re RE=re.compile(&#39; w+&#39;) class sentence: def __init__(self,text): self.text=text self.words=RE.findall(text) def __getitem__(self,index): return self.words[index] def __len__(self): return len(self.words) def __repr__(self): return &quot;sentence(%s)&quot;%reprlib.repr(self.text) . Let&#39;s check if the class sentence is an iterable or not. . iter(sentence(&quot;ABCD Nice Song&quot;)) . &lt;iterator at 0x7f3dabbb1710&gt; . We can see that it is indeed an iterable. The reason being that this class implements $__getitem__$ and also that iter does not return a TypeError. Now let&#39;s see what will happen if the $__getitem__$ is not implemented within this class. . import reprlib import re RE=re.compile(&#39; w+&#39;) class sentence: def __init__(self,text): self.text=text self.words=RE.findall(text) def __len__(self): return len(self.words) def __repr__(self): return &quot;sentence(%s)&quot;%reprlib.repr(self.text) iter(sentence(&quot;ABCD Nice Song&quot;)) . TypeError Traceback (most recent call last) &lt;ipython-input-43-b496195abce1&gt; in &lt;module&gt;() 12 return &#34;sentence(%s)&#34;%reprlib.repr(self.text) 13 &gt; 14 iter(sentence(&#34;ABCD Nice Song&#34;)) TypeError: &#39;sentence&#39; object is not iterable . Since $__getitem__$ is not implemented iter returns a TypeError as we have learnt before. . Let&#39;s redefine an iterable: any object from which the iter built in function can obtain an iterator is called as an iterable. . Behind the curtain, within a &quot;for loop&quot; iterables gets converted to an iterator. . Let&#39;s see an example: In the following snippets the first one is just iterating through a given string &#39;s&#39; which is an iterable and behind the curtain within the for loop it becomes an iterator, in the second snippet it becomes clear how &#39;s&#39; is converted to an iterator and also we can attempt to define an iterator. . s=&#39;ABC&#39; # Here, s is an iterable for char in s: # Here, s gets converted to an iterator print(char) . A B C . s=&#39;ABC&#39; it=iter(s) # checks if s is an iterable, if so returns an iterator instance derived from s. while True: try: print(next(it)) # Repeatedly calling next on the iterator to obtain the next item. except StopIteration: # when no next item present in the iterator next returns StopIteration. del it break . A B C . [Try defining a iterator now!] . To summarise the discussion on iterable and iterator let&#39;s discuss Fig 1 given below. . Fig 1 . From fig 1 we can observe that from an iterable object an iterator is generated using $__iter__$ and the iterator has two methods defined in it which are:$__next__$ (that allows us to loop through it) and $__iter__$ (why should we define an iter here?) Notice that the $__iter__$s in iterable and iterator are different in that for the iterator it just returns an instance of it but for an iterable it returns an iterator. . One thing this design does is that all iterators are also iterable. . Definition of iterators:- Any object that implements the $__next__$ no argument method which returns the next item in a series or raises StopIteration when there are no more items. Python iterators also implement the $__iter__$ method so they are iterable as well . Definition of iterables:- Any object from which the iter built in function can obtain an iterator is called as an iterable or a class that implements $__inter__$ method or $__getitem__$ method. . Finally let&#39;s look at an example and correlate it with the workings shown in fig 1. . import reprlib import re RE=re.compile(&#39; w+&#39;) class Sentence: def __init__(self,text): self.text=text self.words=RE.findall(text) def __repr__(self): return &quot;sentence(%s)&quot;%reprlib.repr(self.text) def __iter__(self): return SentenceIterator(self.words) class SentenceIterator: def __init__(self,words): self.words=words self.index=0 def __next__(self): try: word=self.words[self.index] except IndexError: raise StopIteration() self.index+=1 return word def __iter__(self): return self . Let&#39;s check if a sentence object is iterable or not . iter(Sentence(&quot;Hello World&quot;)) . &lt;__main__.SentenceIterator at 0x7f3dabb0e910&gt; . So it is iterable. Let&#39;s create an iterator from a Sentence object . s=Sentence(&quot;Hello World&quot;) it=iter(s) . We can see from the class definiton above that SentenceIterator is also an iterable object. Let&#39;s run the above &#39;it&#39; through a while loop. . while True: try: print(next(it)) except StopIteration: del it break . Hello World . for i in s: print(i) . Hello World . [i for i in s] . [&#39;Hello&#39;, &#39;World&#39;] .",
            "url": "https://varadan13.github.io/import_this/python_notes/2021/04/06/iterators-iterables.html",
            "relUrl": "/python_notes/2021/04/06/iterators-iterables.html",
            "date": " • Apr 6, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "Hey, you what the hell do you mean by rare?",
            "content": "How to quantify the word rare? . Recently many newspaper have begun to use rare quite oftenly. Talks like this reaction to a medicine is rare. . What does this rare mean? . When does a rare become a problem? . Is rare a statistically property of something or what? . How to live with rare?SS .",
            "url": "https://varadan13.github.io/import_this/thought%20snippets/2021/04/01/rare.html",
            "relUrl": "/thought%20snippets/2021/04/01/rare.html",
            "date": " • Apr 1, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "Sub Optimal Solutions in Politics.",
            "content": "Politicians and people in power mostly prefer an easy and mostly sub optimal solution. . Sub optimal solutions mostly includes the use of coercion or a type of it. .",
            "url": "https://varadan13.github.io/import_this/thought%20snippets/2021/04/01/politico.html",
            "relUrl": "/thought%20snippets/2021/04/01/politico.html",
            "date": " • Apr 1, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "Eigen values and Eigen vectors",
            "content": "Learning objectives . To define eigen values and vectors and state some of their properties | To factorize a square matrix $A$ into $S Lambda S^{-1}$. | Factorizing a symmetric matrix | Spectral theorem | Positive definite matrices | Singular value decomposition | . Section 1: Basics . Let A be a matrix and x be a vector. How to interpret Ax? If Ax is possible then Ax is a vector in a space spanned by the columns of A(column space of A). So another way to look at it is that A transforms vector x (i.e., change of scale, direction) into a vector y (=Ax) which lies in the column space of A. . Eigen vectors are a special type of vectors where they don&#39;t change direction but their length changes when multiplied with A OR Eigen vectors are those vectors that satisfies the equation $Ax= lambda x$ where $ lambda$ can be a fraction, any integer etc. The number $ lambda$ is the eigen value. . Note- Let $A = I$ where $I$ is the identity matrix. For A, all vector x is an Eigen vector with eigen value = 1. . Example . Lets illustrate the above definition using the example below . $Ax = begin{pmatrix} .8 &amp; .3 .2 &amp; .7 end{pmatrix}x= lambda x$ | Here to extract the eigen values we must solve the following equation. . $(A- lambda I)x=0 $ if the eigen value exist then the determinat of $A- lambda I$ must be equal to zero. (why?) . Therefore the equation we must solve here (after all simplification) equals $2 lambda ^2-3 lambda +1 =0$ , we get $ lambda = 1,1/2$ and substituting for $ lambda$ in 1 we can extract the corresponding eigen vectors and they are . $x= begin{pmatrix}.6 .4 end{pmatrix}, lambda = 1$ &amp; $x= begin{pmatrix}1 -1 end{pmatrix}, lambda = 1/2$ . Let us think about the geometry of eigen vectors. when x is multiplied with A the eigen vector with $ lambda$ value = 1 stays the same in direction and in length but for $ lambda$ = 1/2 that eigen vectors magnitude halves. . Elimination does not perserve the $ lambda$s | The product of n eigen values equals the determinant of the matrix | The sum of n eigen values is equal to the sum of the diagonal values of a matrix which is called the trace of the matrix. | One of the many applications of eigen values is that they help in computing large powers of a given matrix(what type of matrix?) i.e., Let&#39;s say $A^{100}$ | . Finding eigen values and vectors in python . import numpy as np . A=np.array([[1,2,1],[3,5,2],[4,3,4]]) print(A) . [[1 2 1] [3 5 2] [4 3 4]] . eigen_values,eigen_vectors=np.linalg.eig(A) #the obtained eigen vectors are unit vectors. . print(eigen_values) . [ 8.37685015 -0.30893252 1.93208237] . print(eigen_vectors) # i th row represent the eigen vector of the respective # i th eigen value . [[-0.27355094 -0.78788511 -0.09183165] [-0.65834893 0.23001831 -0.47923262] [-0.70124644 0.57125181 0.87287058]] . Trace=A[0][0]+A[1][1]+A[2][2] sum_of_eigen_values = round(np.sum(eigen_values),1) print(&quot;trace of the matrix A = &quot;,float(Trace)) print(&quot;Sum of the eigen values of A = &quot;,sum_of_eigen_values) . trace of the matrix A = 10.0 Sum of the eigen values of A = 10.0 . To show that elimination does not perserve $ lambda$s. . Let P be a permutation matrix. P reduces row 2 by subtracting the values in row 2 with the corresponding values in row 1 multiplied by 3. . P=np.array([[1,0,0],[-3,1,0],[0,0,1]]) . print(P@A) . [[ 1 2 1] [ 0 -1 -1] [ 4 3 4]] . B=P@A . eig_values_B,eig_vectors=np.linalg.eig(B) . print(&quot;eigen values of A after elimination = &quot;,eig_values_B) print(&quot;eigen values of A bfore elimination = &quot;,eigen_values) . eigen values of A after elimination = [ 4.1925824 1. -1.1925824] eigen values of A bfore elimination = [ 8.37685015 -0.30893252 1.93208237] . $(A- lambda I)x=0 $ if the eigen value exist then the determinat of $A- lambda I$ must be equal to zero. (why?) . Basically, if there exist a x other than the trivial zero/null vector it means that the null space spanned by $A- lambda I$ contains vectors other than the null vector and also implies that the vectors sitting in the columns of $A- lambda I$ are dependent which means the matrix don&#39;t have full column rank which implies that determinant of $A- lambda I$ is equal to zero. . Summary . An eigenvector or characteristic vector of a linear transformation (read Matrix for now) is a nonzero vector that changes at most by a scalar factor when that linear transformation is applied to it. | The sum and product of the A&#39;s equal the trace and delerminant of A respectively | Elimination does not perserve the λs | . Note The eigenvalues of $A^2$ &amp; $A^{-1}$ are $ lambda ^2$ &amp; $ lambda ^{-1}$ respectively . Note if x is an eigen vector of A then Ax is simply reduced to $ lambda x$. Similarly, AAx=$ lambda lambda x$. We can generalise it as $A^{n}x= lambda ^{n}x$ where x is an eigen vector . Section 2 : Diagonalizing a matrix using Eigen vectors . (2.1) Suppose the n by n matrix A has n linearly independent eigen vectors $x_1,x_2,...,x_n$ and S be a matrix whose columns contains these n independent eigen vectors then $S^{-1}AS = Lambda$ where $ Lambda$ is eigen value matrix of A and also diagonalized matrix of A. . What is the Eigen Value Matrix of A? A matrix that contains eigen values of A in its diagonal position with off diagonal entry equals to zero. . Let&#39;s use (2.1) to rewrite A in a more meaningful way. From (2.1) $S^{-1}AS = Lambda$ which implies that $AS=S Lambda$ and this can be written as $A=S Lambda S^{-1}$. . (2.2) $A=S Lambda S^{-1}$ iff eigen vectors are linearly independent. OR in other words all the eigen vectors are unique. Matrices with repeated eigen values cannot be factorised into this form because S will not be invertible(why?) . Note S is not a unique matrix (why?) . What is the meaning of (2.2)? How can we use it? Let A be a matrix that can be factorised into (2.2) now it becomes easy to compute $A^{n}$ because $A^{n}=S Lambda^{n} S^{-1}$ . def check_uniqueness(eigen_value): checker=[i for i in range(0,len(eigen_value)-1) for j in range(i+1,len(eigen_value)) if eigen_value[i]==eigen_value[j]] if len(checker)==0: return &#39;UNIQUE&#39; else: return &#39;NOT UNIQUE&#39; . def diagonalizer(A): eigen_value,w=np.linalg.eig(A) if check_uniqueness(eigen_value)==&#39;UNIQUE&#39;: return np.round(np.linalg.inv(w)@(A@w),3) else: print(&quot;Sorry the matrix does not have unique eigen values&quot;) . A=np.array([[1,2,1],[3,5,2],[4,3,4]]) e,_=np.linalg.eig(A) print(diagonalizer(A)) print() print(&quot;the eigen values of the Matrix A = &quot;, e) . [[ 8.377 -0. -0. ] [ 0. -0.309 0. ] [ 0. 0. 1.932]] the eigen values of the Matrix A = [ 8.37685015 -0.30893252 1.93208237] . Setion 3:Diagonalizing a symmetric matrix . 3.1 Definition A is a symmetric matrix if $A=A^{T}$ . Let&#39;s explore using an example . $sys = begin{pmatrix} 5 &amp; 6 &amp; 7 6 &amp; 3 &amp; 2 7 &amp; 2 &amp; 1 end{pmatrix}$ we can see that sys is a 3*3 symmetric matrix. . sys = np.array([[5,6,7],[6,3,2],[7,2,1]]) # Let&#39;s check if the eigen values of sys matrix is unique or not eig,_=np.linalg.eig(sys) check_uniqueness(eig)==&#39;UNIQUE&#39; . True . Therefore eigen values of sys matrix is unique. . Let&#39;s check out the eigen vector matrix of sys . eig,S=np.linalg.eig(sys) print(&quot;the eigen vector matrix of sys = n&quot;, S) . the eigen vector matrix of sys = [[ 0.72541697 0.66666667 0.17124772] [ 0.49566405 -0.33333333 -0.80200127] [ 0.47758494 -0.66666667 0.57224835]] . What are the properties of S? . eig_vec1,eig_vec2,eig_vec3=S[:,0],S[:,1],S[:,2] . round(np.dot(eig_vec1,eig_vec2),3) . -0.0 . round(np.dot(eig_vec2,eig_vec3),3) . 0.0 . round(np.dot(eig_vec3,eig_vec1),3) . -0.0 . The first thing therefore we notice is that the eigen vectors are orthogonal to each other . np.round(S@S.T,3) . array([[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]]) . np.round(S.T@S,3) . array([[ 1., 0., -0.], [ 0., 1., 0.], [-0., 0., 1.]]) . The second thing we notice is that the inverse of eigen vector matrix is its transpose therefore eigen vector matrix of a symmetric matrix is an orthogonal matrix . (3.2) Definition Orthogonal matrix An orthogonal matrix is a real square matrix whose columns and rows are orthogonal vectors OR $M*M^{-1}=I$ where M is the orthogonal matrix. . Here, the eigen vector matrix is not only orthogonal but also orthonormal because numpy normalises the obtained eigen vectors into unit vectors. . For example:- . round(np.dot(eig_vec1,eig_vec1),3) . 1.0 . What are the properties of S? i.e., eigen vector matrix of a symmetric matrix . eigen vectors are orthogonal to each other | the inverse of eigen vector matrix is its transpose therefore eigen vector matrix of a symmetric matrix is an orthogonal matrix | if the eigen vectors are unit vectors then the eigen vector matrix is an orthonormal matrix. | . Now let&#39;s answer the question, what is the form of matrix diagonalisation when the matrix is symmetric? . $S^{-1}AS= Lambda$ this is when A is non symmetric when A is symmetric the equation becomes $S^{T}AS= Lambda$ . This journey culminates with the spectral theorem . (3.3) Spectral theorem Every symmetric matrix A can be factorised as $S Lambda S^{T}$ with $ Lambda$ matrix holding real eigen values in its diagonal position and orthonormal eigen vectors sitting in the columns of S matrix. . Summary of Section 2 and 3 . We have learnt that A can be factorised into $A=S Lambda S^{-1}$ | This factorisation can be used to seamlessly compute $A^{n}$ by using the following formula $A^{n}=S Lambda^{n} S^{-1}$. | . Section 4: Positive definite &amp; Singular Value Decomposition . (4.1) Definition Positive definite matrix A symmetric matrix whose eigen values are all positive . How to test for positive definitness? The matrix A is positive definite if $x^{T}Ax&gt;0$ for all nonzero vector X .",
            "url": "https://varadan13.github.io/import_this/linear%20algebra%20tutorial/2021/03/26/EIGEN-VALUE.html",
            "relUrl": "/linear%20algebra%20tutorial/2021/03/26/EIGEN-VALUE.html",
            "date": " • Mar 26, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": ". Become the teacher I never had .",
          "url": "https://varadan13.github.io/import_this/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://varadan13.github.io/import_this/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}