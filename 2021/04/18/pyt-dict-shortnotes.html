<p>On hashable objects</p>

<ul>
  <li>
    <p>An object is hashable if it has a hash value which never changes during its lifetime (it needs a <strong>hash</strong>() method), and can be compared to other objects (it needs an__eq__() method).</p>
  </li>
  <li>
    <p>Python Glossary states: “All of Python’s immutable built-in objects are hashable” but that is inaccurate because a tuple is immutable, yet it may contain references to unhashable objects.</p>
  </li>
  <li>
    <p>If  you  implement  a  class  with  a  custom  <strong>eq</strong>  method  then  you must  also  implement  a  suitable  <strong>hash</strong>,  because  you  must  always make  sure  that  if  a  ==  b  is  True  then  hash(a)  ==  hash(b)  is  also True.  Otherwise  you  are  breaking  an  invariant  of  the  hash  table algorithm,  with  the  grave  consequence  that  dicts  and  sets  will  not deal  reliably  with  your  objects.  If  a  custom  <strong>eq</strong>  depends  on  mutable  state,  then  <strong>hash</strong>  must  raise  TypeError  with  a  message  like unhashable  type:  ‘MyClass’.</p>
  </li>
</ul>

<p>On how python mapping objects deals with missing values</p>

<ul>
  <li>
    <p>Underlying method used to deal with missing keys is the aptly named  <strong>missing</strong> method. This method is not defined in the base  dict  class, but  dict  is aware of it: if you subclass  dict and provide a  <strong>missing</strong> method, the standard dict.<strong>getitem</strong> will call it whenever a key is not found, instead of raising  KeyError.</p>
  </li>
  <li>
    <p>The  <strong>missing</strong>  method is just called by  <strong>getitem</strong>, i.e. for the d[k]  operator. The presence of a  <strong>missing</strong> method has no effect  on the behavior of other  methods  that  look  up  keys,  such  as  get or  <strong>contains</strong>  (which  implements  the  in  operator).</p>
  </li>
</ul>

<p>On update method of dict</p>

<ul>
  <li>The way update handles its first argument  m is a prime example of  duck typing: it first checks whether  m  has a  keys  method and, if it does, assumes it is a mapping. Otherwise, update  falls back to iterating over  m, assuming its items are  (key, value)  pairs.</li>
</ul>

<p>Practical consequences of how dict works</p>

<ul>
  <li>
    <p>Keys must be hashable objects</p>
  </li>
  <li>
    <p>dicts have significant memory overhead</p>
  </li>
  <li>
    <p>Key search is very fast</p>
  </li>
  <li>
    <p>Key ordering depends on insertion order</p>
  </li>
  <li>
    <p>Adding items to a dict may change the order of existing keys</p>
  </li>
</ul>

<p>Practical consequences of how set works</p>

<ul>
  <li>
    <p>Set elements must be hashable objects.</p>
  </li>
  <li>
    <p>Sets have a significant memory overhead.</p>
  </li>
  <li>
    <p>Membership testing is very efficient.</p>
  </li>
  <li>
    <p>Element ordering depends on insertion order.</p>
  </li>
  <li>
    <p>Adding elements to a set may change the order of other elements.</p>
  </li>
</ul>

<p>On null set construction</p>

<ul>
  <li>Syntax quirk Don’t forget: to create an empty set, use the constructor  without an argument: set(). If you write {}, you’re creating an empty dict  — this  hasn’t  changed</li>
</ul>
